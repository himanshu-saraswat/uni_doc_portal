"use strict";

var URI = require("urijs");

var fs = require("fs");

var LZString = require("lz-string");

var _require = require("path"),
    join = _require.join;

var map = require("unist-util-map");

var normalizePath = require("normalize-path");

var npa = require("npm-package-arg");

var _require2 = require("./constants"),
    OPTION_DEFAULT_LINK_TEXT = _require2.OPTION_DEFAULT_LINK_TEXT,
    OPTION_DEFAULT_HTML = _require2.OPTION_DEFAULT_HTML,
    PROTOCOL_BABEL = _require2.PROTOCOL_BABEL,
    PROTOCOL_CODEPEN = _require2.PROTOCOL_CODEPEN,
    PROTOCOL_CODE_SANDBOX = _require2.PROTOCOL_CODE_SANDBOX,
    PROTOCOL_RAMDA = _require2.PROTOCOL_RAMDA; // Matches compression used in Babel and CodeSandbox REPLs
// https://github.com/babel/website/blob/master/js/repl/UriUtils.js


var compress = function compress(string) {
  return LZString.compressToBase64(string).replace(/\+/g, "-") // Convert '+' to '-'
  .replace(/\//g, "_") // Convert '/' to '_'
  .replace(/=+$/, "");
}; // Remove ending '='


function convertNodeToLink(node, text, href, target) {
  target = target ? "target=\"" + target + "\" rel=\"noreferrer\"" : "";
  delete node.children;
  delete node.position;
  delete node.title;
  delete node.url;
  node.type = "html";
  node.value = "<a href=\"" + href + "\" " + target + ">" + text + "</a>";
}

module.exports = function (_ref, _temp) {
  var markdownAST = _ref.markdownAST;

  var _ref2 = _temp === void 0 ? {} : _temp,
      _ref2$defaultText = _ref2.defaultText,
      defaultText = _ref2$defaultText === void 0 ? OPTION_DEFAULT_LINK_TEXT : _ref2$defaultText,
      _ref2$dependencies = _ref2.dependencies,
      dependencies = _ref2$dependencies === void 0 ? [] : _ref2$dependencies,
      directory = _ref2.directory,
      _ref2$html = _ref2.html,
      html = _ref2$html === void 0 ? OPTION_DEFAULT_HTML : _ref2$html,
      target = _ref2.target;

  if (!directory) {
    throw Error("Required REPL option \"directory\" not specified");
  } else if (!fs.existsSync(directory)) {
    throw Error("Invalid REPL directory specified \"" + directory + "\"");
  } else if (!directory.endsWith("/")) {
    directory += "/";
  }

  var getFilePath = function getFilePath(url, protocol, directory) {
    var filePath = url.replace(protocol, "");

    if (!filePath.includes(".")) {
      filePath += ".js";
    }

    filePath = normalizePath(join(directory, filePath));
    return filePath;
  };

  var getMultipleFilesPaths = function getMultipleFilesPaths(urls, protocol, directory) {
    return urls.replace(protocol, "").split(",").map(function (url) {
      if (!url.includes(".")) {
        url += ".js";
      }

      return {
        url: url,
        // filename itself
        filePath: normalizePath(join(directory, url)) // absolute path

      };
    });
  };

  var verifyFile = function verifyFile(path, protocol) {
    if (protocol !== PROTOCOL_CODE_SANDBOX && path.split(",").length > 1) {
      throw Error("Code example path should only contain a single file, but found more than one: " + path.replace(directory, "") + ". " + ("Only CodeSandbox REPL supports multiple files entries, the protocol prefix of which starts with " + PROTOCOL_CODE_SANDBOX));
    }

    if (!fs.existsSync(path)) {
      throw Error("Invalid REPL link specified; no such file \"" + path + "\"");
    }
  };

  var verifyMultipleFiles = function verifyMultipleFiles(paths, protocol) {
    return paths.forEach(function (path) {
      return verifyFile(path.filePath, protocol);
    });
  };

  map(markdownAST, function (node, index, parent) {
    if (node.type === "link") {
      if (node.url.startsWith(PROTOCOL_BABEL)) {
        var filePath = getFilePath(node.url, PROTOCOL_BABEL, directory);
        verifyFile(filePath, PROTOCOL_BABEL);
        var code = compress(fs.readFileSync(filePath, "utf8"));
        var href = "https://babeljs.io/repl/#?presets=react&code_lz=" + code;
        var text = node.children.length === 0 ? defaultText : node.children[0].value;
        convertNodeToLink(node, text, href, target);
      } else if (node.url.startsWith(PROTOCOL_CODEPEN)) {
        var _filePath = getFilePath(node.url, PROTOCOL_CODEPEN, directory);

        verifyFile(_filePath, PROTOCOL_CODEPEN);

        var _href = node.url.replace(PROTOCOL_CODEPEN, "/redirect-to-codepen/");

        var _text = node.children.length === 0 ? defaultText : node.children[0].value;

        convertNodeToLink(node, _text, _href, target);
      } else if (node.url.startsWith(PROTOCOL_CODE_SANDBOX)) {
        var filesPaths = getMultipleFilesPaths(node.url, PROTOCOL_CODE_SANDBOX, directory);
        verifyMultipleFiles(filesPaths, PROTOCOL_CODE_SANDBOX); // CodeSandbox GET API requires a list of "files" keyed by name

        var parameters = {
          files: {
            "package.json": {
              content: {
                dependencies: dependencies.reduce(function (map, dependency) {
                  var _npa = npa(dependency),
                      name = _npa.name,
                      fetchSpec = _npa.fetchSpec;

                  map[name] = fetchSpec;
                  return map;
                }, {}),
                main: filesPaths[0].url
              }
            },
            "index.html": {
              content: html
            }
          }
        };
        filesPaths.forEach(function (path, i) {
          var code = fs.readFileSync(path.filePath, "utf8");
          parameters.files[path.url] = {
            content: code
          };
        }); // This config JSON must then be lz-string compressed

        parameters = compress(JSON.stringify(parameters));

        var _href2 = "https://codesandbox.io/api/v1/sandboxes/define?parameters=" + parameters;

        var _text2 = node.children.length === 0 ? defaultText : node.children[0].value;

        convertNodeToLink(node, _text2, _href2, target);
      } else if (node.url.startsWith(PROTOCOL_RAMDA)) {
        var _filePath2 = getFilePath(node.url, PROTOCOL_RAMDA, directory);

        verifyFile(_filePath2, PROTOCOL_RAMDA); // Don't use `compress()` as the Ramda REPL won't understand the output.
        // It uses URI to encode the code for its urls, so we do the same.

        var _code = URI.encode(fs.readFileSync(_filePath2, "utf8"));

        var _href3 = "http://ramdajs.com/repl/#?" + _code;

        var _text3 = node.children.length === 0 ? defaultText : node.children[0].value;

        convertNodeToLink(node, _text3, _href3, target);
      }
    } // No change


    return node;
  });
  return markdownAST;
};